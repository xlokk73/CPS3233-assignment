\documentclass[a4paper, 12pt]{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{dot2texi}
\usetikzlibrary{automata, positioning, arrows}
\usepackage{booktabs}
\usepackage{tablefootnote}
\usepackage{adjustbox}


\setlength\parindent{24pt}

\lstset{language=python,breaklines=true, frame=single}
\tikzset{
        ->,  % makes the edges directed
        %>=stealth’, % makes the arrow heads bold
        node distance=6cm, % specifies the minimum distance between two nodes. Change if n
        every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ n
        initial text=$ $, % sets the text that appears on the start arrow
        }

\begin{document}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{Logo}
\end{figure}

\title{CPS3233 Assignment Report}
\author{Manwel Bugeja}
\date{\today}
\maketitle
  
\tableofcontents
\newpage

\section{Elevator System Specification}
In this section, the specifications of the elevator system are expressed in several different formal notations. The notations are Finite State Automata (FSAs), Regular Expressions (RE), Timed Automata (TAs) and Duration Calculus (DC). From the ones listed, TAs and DC are the capable of expressing timed events. \\

\subsection{Finite State Automata}
A finite state automata was designed to describe the elevator system. The formal definition of the state machine can be seen in listing \ref{lst:FSA}. The lift can be in one of three states: Idle, Loading or Moving. Idle is when the lift is not moving and has its door closed. Loading when the lift is not moving but has the doors open. Moving is when the lift is moving either up or down. Note that a 'bad' state could be added for when the lift is moving and has the doors open as the lift should never be in this state. \\

This FSA describes the flow of the lift lifetime in a very basic nature for example it does not consider elevator summoning or floor requests. This can be seen visually in figure \ref{fig:FSA}. A more detailed automaton considering more actions and time constraints is discussed in section \ref{sec:timed-automata}.



\begin{lstlisting}[
caption={FSA definition}
\label{lst:FSA}
]
M = {
{Idle, Loading, Moving},
{openDoor, closeDoor, stop, goUp, goDown},
{
    Idle, openDoor -> Loading,
    Idle, goUp -> Moving,
    Idle, goDown -> Moving,
    Loading, closeDoor -> Idle,
    Moving, stop -> Idle
},
Idle,
{}
}
\end{lstlisting}





\begin{figure}[h] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
    \centering % centers the figure
    \begin{tikzpicture}
        % tikz code goes here
        \node[state, initial] (Idle) {Idle};
        \node[state, right of=Idle] (Loading) {Loading};
        \node[state, right of=Loading] (Moving) {Moving};
        
        \draw (Idle) edge[bend left, below] node{openDoor} (Loading);
        \draw (Loading) edge[bend left, above] node{closeDoor} (Idle);
       	\draw (Idle) edge[bend left, above] node{goUp/goDown} (Moving);
	\draw (Moving) edge[bend left, below] node{stop} (Idle);
        
    \end{tikzpicture}
    \caption{Basic FSA}
    \label{fig:FSA}
\end{figure}


\subsection{Regular Expressions}
The lift system was also expressed via regular expressions. This RE can be seen in listing \ref{lst:RE}. The RE starts of with a series of \textit{openDoor} and \textit{closeDoor} actions which must occur consecutively. This is done so that when the lift moves to the next stage in the RE, the door is always closed, since the lift cannot move with its door open. \\

Next, the RE verifiers that the lift goes an arbitrary number of steps up or down (depending on what the user decided) followed by a stop. The \textit{stop} is there to make sure the lift is not moving when the progress move back to the open/close door part of the expression. \\

An example run of the elevator is:
\texttt{openDoor > closeDoor > goUp > goUp > stop > openDoor > closeDoor > openDoor > closeDoor > goDown > stop}.
This run through is correct according to the RE provided. 

\begin{lstlisting}[
caption={RE definition}
\label{lst:RE}
]
((openDoor.closeDoor)* (goUp* + goDown*).stop )*

\end{lstlisting}


\subsection{Timed Automata}
\label{sec:timed-automata}
For the timed automata (figure \ref{fig:TA}, the same state machine above was used with some clocks and states added to verify time-constrained events. In the formal definition of the automaton, the transition functions where modified to accommodate such changes. The formal specification can be seen in listing \ref{lst:TA}. The transition functions follow the format \texttt{[from, to, letter, clocks reseted, condition]}. \\

The first time property that is handled says that "upon a request, after the door closes, the elevator starts moving in less than 3 seconds". When adapted to the provided automaton, this translates to "when the lift is \textit{Idle} (because a floor button was pressed so the door closed), it goes either up or down in less than 3 seconds". This is verified by clock x. \\

The second time property expresses that "after the door has been open for 3 seconds, it closes automatically". This implies that when the lift has its doors opened i.e. its in the \textit{Loading} state, it must go to the \textit{Idle} in less than 3 seconds. This is because if a user presses the button in less than 3 seconds, the door will close and if he does not press any button, the door closes automatically. This is verified by clock y.  \\

The two new states are \texttt{Requested} and \texttt{LoadingRequested}. A new event, \texttt{requested} is also added to the alphabet. These new additions concern the summon button present at each floor. The \texttt{Requested} state signifies when the lift a floor was requested while the lift was moving or idle. The state \texttt{LoadingRequested} is the same except that before the request, the lift was in the \texttt{Loading} state. \\

The state \texttt{Requested} was added for the time property that states that the lift must start moving in less than 3 seconds i.e., the time property handles by clock x. Therefore, every transition that leads to the \texttt{Requested} state resets clock x. Meanwhile, \texttt{LoadingRequested}) is needed for the close-door time property handled by clock y. 

\begin{lstlisting}[
caption={TA definition}
\label{lst:TA}
]
M = {
{openDoor, closeDoor, stop, goUp, goDown},
{Idle, Loading, Moving},
{idle},
{x, y},
{
    [ Idle, Loading, openDoor, {y:=0}, true ]
    
    [ Idle, Requested, request, {x:=0}, true ]
        
    [ Loading, Idle, closeDoor, {x:=0}, y<3 ]
    
    [Loading, LoadingRequested, request, {}, true]
    
    [ Moving, Idle, stop, {x:=0}, true ]
    
    [ LoadingRequested, Requested, closeDoor, {x:=0}, y<3 ]
    
    [ Requested, Moving, goUp/goDown, {}, x<3 ]
}
}
\end{lstlisting}


\begin{figure}[h] %  figure placement: here, top, bottom, or page
   \centering
\begin{adjustbox}{max width=\textwidth}


    \centering % centers the figure
    \begin{tikzpicture}[>=stealth,auto,state/.append style={fill=black!10}]
        % tikz code goes here
        \node[state, initial] (Idle) {Idle};
        \node[state, right of=Idle] (Loading) {Loading};
        \node[state, left of=Idle] (Moving) {Moving};
        \node[state, above right of=Moving] (Requested) {Requested};
        \node[state, right of=Loading] (LoadingRequested) {LoadingRequested};
        
        \draw (Idle) edge[bend right, below] node{openDoor, y:=0} (Loading);
        \draw (Loading) edge[bend right, above] node{closeDoor, x:=0, y$<$3} (Idle);
	\draw (Moving) edge[bend right, below] node{stop, x:=0} (Idle);
	\draw (Moving) edge[bend right, below] node{request} (LoadingRequested.south);
	\draw (Requested) edge[bend right, below] node{goUp/goDown, x$<$3} (Moving);
	\draw (Loading) edge[bend right, below] node{request} (LoadingRequested);
        \draw (LoadingRequested) edge[bend right, above] node{closeDoor, y$<$3, x:=0}(Requested);
        \draw (Idle) edge[bend right, below] node{request, x:=0} (Requested);
        
    \end{tikzpicture}

\end{adjustbox}

\caption{FSA figure}
\label{fig:FSA}

\end{figure}




\subsection{Duration Calculus}
For the DC specifications, two formulas where defined, one for each time constrain. The first time constrain states that: "upon a request, after the door closes, the elevator starts moving in less than 3 seconds". This is expressed by the formula:

$$\square [Idle] ; [Loading] ;  [Moving]  \wedge [idle] ; [Loading] ; [Idle] \Rightarrow \int loading < 3$$

The square means that it is checking for all subintervals. Then the pattern the formula is looking for is \textit{Idle}, followed my \textit{Loading}, followed by \textit{Moving}. Then, the expression verifies that the time of loading is less than 3.

The second time constrain says that: after the door has been open for 3 seconds, it closes automatically". The formula describing this is as follows:

$$\square [doorOpen] ; [\neg doorOpen] \Rightarrow \int doorOpen < 3$$

The formula looks for the pattern of an open door followed by a closed door and then verifies that the door was open for less than 3 seconds. 

\section{Runtime Verification}

For runtime verification, the Larva tool was used. The automata applied where directly derived from the timed automaton discussed in section \ref{sec:timed-automata}. However, it was not implemented as a single automaton in order to check for properties individually. \\

The first property investigated was the door close property. First off, to make the investigation simpler, a single lift was considered. This is because the automaton designed only considers one lift. The Java code was analysed to find the methods that correspond with the designed events. These methods were present in \textit{Lift.java}. The methods and their corresponding events is shown in table \ref{tab:lift-open-time-property}.

% Requires the booktabs if the memoir class is not being used
\begin{table}[htbp]
   \centering
   %\topcaption{Table captions are better up top} % requires the topcapt package
   \begin{tabular}{@{}  |c|c| @{}} % Column formatting, @{} suppresses leading/trailing spac
      \toprule
      Method    & Event \\
      \midrule
      Lift.setMoving(boolean isMoving)   &  goUp/goDown *\\
      Lift.closeDoors()       & closeDoor  \\
      Lift.openDoors()       & openDoor  \\
      Lift.setFloor() & stop    \\
      \bottomrule
   \end{tabular}
   \caption{LiftOpenTimeProperty events table}
   \tablefootnote{*isMoving parameter must be true}
   \label{tab:lift-open-time-property}
\end{table}

To add support for multiple lift, the \texttt{FOREACH} Larva keyword was used to iterate over lift objects. All the event methods resided in the class \textit{Lift.java}. This meant that adding multiple lift support was done by binding the Lift object in the event declarations and then assigning it to the \texttt{FOREACH} object using the \texttt{WHERE} keyword.


\begin{lstlisting}[
language=bash, 
caption={Multiple lift support for LiftOpenProperty}
\label{lst:labelname}
]
setMoving(isMoving) = {Lift l.setMoving(boolean isMoving)} WHERE {lift = l;} 
closeDoors() = {Lift l.closeDoors()} WHERE {lift = l;}
openDoors() = {Lift l.openDoors()} WHERE {lift = l;}
setFloor() = {Lift l.setFloor(*)} WHERE {lift = l;}
\end{lstlisting}

The second property is called \texttt{StartMovingTimeProperty} and verifies that the lift start moving in less than 3 seconds after the door closes following a request. A new event was added for the summon request action. The method that corresponds to this event is \texttt{callLiftToFloor}. \\

This method provided some difficulty when switching to adding support for multiple lift verification. The reason being that this method does not reside in the \textit{Lift.java} class. It resided in the \textit{JavaController.java} class. When \texttt{callLiftToFloor} is called, it performs some calculations and then proceeds to execute \texttt{moveLift} with the chosen lift. To find out which lift was called via Larva, the source needed to be edited. The change done was very minimal and does not impact the design of the lift system at all. The \texttt{callLiftToFloor} method signature was changed to return a lift object instead of void. This is then used by Larva by making use of the \texttt{uponReturning} keyword when declaring the event. The whole event declaration is as follows: \newline\texttt{callLiftToFloor(Lift l) = {*callLiftToFloor(*)uponReturning(l)} where {lift = l;}}, where '\texttt{lift}' is the iterated object declared in the FOREACH loop. 

\subsection{Testing}
In the tests shown, one property at a time was tested to make the outputs more legible. Figure \ref{fig:lift-open-test-passed} shows the property \texttt{LiftOpenTimeProperty} running as should. several buttons were pressed and the lift always moved as specified. \\

\begin{figure}[h]
   \centering
   \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/lift-open-test-passed} % requires the graphicx package
   \caption{\texttt{LiftOpenTimeProperty} verified}
   \label{fig:lift-open-test-passed}
\end{figure}

For the second test shown in figure \ref{fig:lift-open-test-failed}, time taken to close the door automatically was changed from the java source code in file \textit{Shaft.java}. The figure shows that verification failed because the door was closing after 3 seconds. \\

\begin{figure}[h]
   \centering
   \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/lift-open-test-failed} % requires the graphicx package
   \caption{\texttt{LiftOpenTimeProperty} failed}
   \label{fig:lift-open-test-failed}
\end{figure}

Referirng to figure \ref{fig:lift-open-test-multiple} the third test shown, displays the verification being conducted on several (three) lifts. Identifiers are used to differentiate the multiple lifts being verified. \\

\begin{figure}[h]
   \centering
   \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/lift-open-test-multiple} % requires the graphicx package
   \caption{\texttt{LiftOpenTimeProperty} on several lifts}
   \label{fig:lift-open-test-multiple}
\end{figure}

Figure \ref{fig:start-moving-time-property-several} shows the fourth documented test. This test shows the verification of the \texttt{StartMovingTimeProperty} working on more than one lift. To make the output more clear, the \texttt{LiftOpenTimeProperty} was removed from the script to focus only on the property discussed. \\
\begin{figure}[h]
   \centering
   \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/start-moving-time-property-several} % requires the graphicx package
   \caption{\texttt{StartMovingTimeProperty} on several lifts}
   \label{fig:start-moving-time-property-several}
\end{figure}

A failure was also induced for this property. The \texttt{animateLift} method in \textit{Shaft.java} was edited to wait three seconds before starting to move the lift. The added code can be seen in figure \ref{fig:start-moving-time-property-failure-edit}. As expected, this caused the verification to fail. The output can be seen in figure \ref{fig:start-moving-time-property-failed}

\begin{figure}[h]
   \centering
   \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/start-moving-time-property-failure-edit} % requires the graphicx package
   \caption{Added code to stop for three seconds before starting to move lift in \textit{Shaft.java}}
   \label{fig:start-moving-time-property-failure-edit}
\end{figure}

\begin{figure}[h]
   \centering
   \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/start-moving-time-property-failed} % requires the graphicx package
   \caption{\texttt{StartMovingTimeProperty} failure}
   \label{fig:start-moving-time-property-failed}
\end{figure}

The final test showcased in this section can be seen in figure \ref{fig:all-properties}. This shows all the properties being run at once for several lifts. 

\begin{figure}[h]
   \centering
   \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/all-properties} % requires the graphicx package
   \caption{All properties}
   \label{fig:all-properties}
\end{figure}

\subsection{Larva script improvements}
The script developed is not perfect. One flaw with the system is that requests are only summon requests. This means that only buttons on floors are verified. The reason for this decision lies in the java source code for the Lift system. As can be seen in figure \ref{fig:floor-request-code} was a button is pressed, it is registered as a \texttt{move} action. As opposed to using a function similar to summon requests where \texttt{callLiftToFloor} is used. \\

One possible way to circumvent this problem would have been to iterate over \texttt{Shaft} objects rather than \texttt{Lift} object as the script does currently. This would have most likely work since each shaft corresponds to a single that resides in it. The \textit{Shaft.java} class also contains \texttt{openDoors()} and \texttt{closeDoors()} methods similar to the \textit{Lift.java} class. Movement events would have been recognised by the \texttt{animateUp()} and \texttt{animateDown()} present in \textit{Shaft.java}. Finally, stopping would have been recognised by the \texttt{animationPause()} method. Iteration over the \texttt{Shaft} objects would enable the script to track which shaft floor buttons were pressed. 

\begin{figure}[htbp]
   \centering
   \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/floor-request-code} % requires the graphicx package
   \caption{Floor request button code}
   \label{fig:floor-request-code}
\end{figure}



\section{Model-Based Testing}

\section{Runtime Verification and Testing}

\bibliographystyle{abbrv}
 \bibliography{references}

\end{document}
